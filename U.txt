/* rexx */                                                                      
trace o                                                                         
/*________________________________________________________________*/            
/*                                                                */            
/* Edit macro executing a z/OS Unix command.                      */            
/*________________________________________________________________*/            
                                                                                
                                                                                
/*________________________________________________________________*/            
/*                                                                */            
/* Help starts                                                    */            
/* u is an edit macro executing a z/OS Unix command.              */            
/*                                                                */            
/* Input to the z/OS Unix command is the                          */            
/* presently edited file.                                         */            
/* The result of the z/OS Unix command, if not empty,             */            
/* replaces the presently edited file,                            */            
/* unless a supplementary keyword 'info' is added .               */            
/* If 'info' is added to the Unix command (anywhere)              */            
/* the result of the Unix command is placed into infolines.       */            
/*                                                                */            
/* The user may cancel the result with:                           */            
/* Command ===> can                                               */            
/* or restore the previous content of a library member with:      */            
/* Command ===> u r  (or u re, u res, u rest etc... or u u)       */            
/* or save the result.                                            */            
/*                                                                */            
/* If the word 'info', in mixed case, does not appear at right    */            
/* of u, then edit macro u by default, saves the previous content */            
/* of a non empty edited library member in another member         */            
/* called 'SAVEU' before replacing this member                    */            
/* by the result of an Unix command.                              */            
/*                                                                */            
/* If keyword 'info', in mixed case, is placed anywhere after u,  */            
/* then the result of an Unix command                             */            
/* does not replace the content but is added                      */            
/* at top of member or sequential file, as infolines.             */            
/* These infolines may be deleted with RES or made datalines with */            
/* line commands MD and MDD.                                      */            
/* The previous content is unchanged and saved in member 'SAVEU'. */            
/*                                                                */            
/* Examples of use in View or Edit:                               */            
/*                                                                */            
/* Command ===> u           (or u help)        <- shows help      */            
/* Command ===> u u         (or u r or u re)   <- restore         */            
/* Command ===> u cut -c 1-10                  <- first 10 char   */            
/* Command ===> u cut -c 1-10,12-              <- col 11 disappears */          
/* Command ===> u sed 's/A.*b/DEF/g'           <- case sensitive  */            
/* Command ===> u iconv -f 1047 -t 1147        <- Unix to French  */            
/* Command ===> u awk 'éprint $1è'             <- Keep 1st field  */            
/* Command ===> u cal 2020                     <- all year        */            
/* Command ===> u cal sep 1752                 <- missing days    */            
/* Command ===> u man sed                                         */            
/* Command ===> u man sed ! cut -c 1-80                           */            
/* Command ===> zexpand                                           */            
/*     u cat "//'BOZO.CNTL(HAYSTACK)'" ! grep -E 'N.*dle'         */            
/* Command ===> u cut -c 1-10 info   <- infolines, no replacement */            
/* Command ===> u info cut -c 1-10   <- infolines, no replacement */            
/* Command ===> u man woman info     <- infolines, no replacement */            
/* Command ===> u ls -al oedit       <- oedit temporary result    */            
/* Command ===> u oedit man awk      <- oedit temporary result    */            
/* oedit is used for long output lines and u may be reissued.     */            
/* Non empty temporary result replaces member or sequential file. */            
/* Command ===> can                  <- not to SAVE u's result    */            
/* Command ===> u s (or u sa, u sav) <- explicit save in 'SAVEU'  */            
/* edit macro u used to process z/OS Unix commands in member:     */            
/*            BOZO.CNTL(A)                                        */            
/* Command ===> u sh                  or ===> u sh info           */            
/* ****** *********************                                   */            
/* 000001 whoami                                                  */            
/* 000002 pwd                                                     */            
/* 000003 printenv                                                */            
/* ****** *********************                                   */            
/* Command ===> u cal jun ., cal jul        <- '.,' replaced by '; ' */         
/* Command ===> u cd /u/bozo ,. cat abc.txt <- ',.' replaced by '; ' */         
/* Help ends                                                      */            
/*________________________________________________________________*/            
/*                                                                */            
                                                                                
/* for bpxwunix command codepage:                                 */            
lc_all = "En_US.IBM-1140"  /* lc_all = "Fr_FR.IBM-1147"           */            
parse source . . rexxname .    /* rexxname in upper case          */            
                                                                                
address isredit                                                                 
'macro (parm)' /* parm may be up to 200 characters in mixed case  */            
call check_parm                /* for help                        */            
                                                                                
/* SAVE or RESTORE                                                */            
W1 = translate(word(parm,1))                                                    
/* If first word of parm translated to uppercase begins by 'S'    */            
   if abbrev('SAVE',W1,1)    then do /* explicit save             */            
      call save                                                                 
      exit 0                                                                    
   end /* if abbrev('SAVE',W1,1)        explicit save             */            
/* If first word of parm translated to uppercase begins by 'R'    */            
/* or is rexxname (Command ===> u u) then restore                 */            
   if abbrev('RESTORE',W1,1) !,      /* or                        */            
      W1 = rexxname          then do /* restore                   */            
      call restore                                                              
      exit 0                                                                    
   end /* if abbrev('RESTORE',W1,1)           restore             */            
                                                                                
/* Set up z/OS Unix command to execute:                           */            
/* temp is a temporary file in /tmp                               */            
/* /tmp is normally automatically cleaned.                        */            
/* It will be copied to replace the presently edited file         */            
/* then deleted (not moved to avoid a possible confirmation       */            
/* panel).                                                        */            
temp = '/tmp/temp'random(1,99999)  /* temporary file              */            
                                                                                
if info = "no"                                                                  
   /* Use of temp file is possibly faster than using stem stdout. */            
   /* We use stem stdout. with bpxwunix                           */            
   /* only when infolines have to be created.                     */            
   then /* info = "no"   redirect standard output to temp         */            
        if pos(';',parm) = 0 then cmd = parm '>' temp   /* no ';' */            
        else cmd = '('parm') >' temp   /* ';' was present in parm */            
   else cmd = parm /* info = "yes"                                */            
                   /* stdout. to be written as infolines          */            
                                                                                
/* Copy content of presently edited file into stem line.          */            
trace_previous = trace("o") /* no trace                           */            
'(last) = linenum .zl'                                                          
drop line.                                                                      
do i = 1 to last                                                                
   '(li)  = line 'i                                                             
   line.i = li                                                                  
end /* do i = 1 to last                                           */            
line.0 = last                                                                   
trace(trace_previous)                                                           
                                                                                
/* Issue z/OS unix command.                                       */            
call set_env /* z/OS Unix environment variables                   */            
drop stderr.; stderr.0 = 0    /* initialize standard error stem   */            
drop stdout.; stdout.0 = 0    /* used only if info = "yes"        */            
call bpxwunix cmd,line.,stdout.,stderr.,env.                                    
bpxwunix_rc = rc                                                                
                                                                                
call check_for_error                                                            
drop line. stderr.                                                              
                                                                                
call save      /* save of a library member in member 'SAVEU'      */            
                                                                                
if info = "no" then do /* no word 'info' after u, default case    */            
                                                                                
   /* Using oedit: Command ===> u cal 2020 oedit                  */            
   /* Content of member not replaced if temp made empty with oedit */           
   if oedit = "yes" then address tso "oedit '"temp"'"                           
                                                                                
   member_replaced = "no"                                                       
   if size(temp) > 0 then do                                                    
      /* Remove all file content.                                 */            
      'del all .zf .zl'                                                         
                                                                                
      /* Copy temporary file then delete it.                      */            
      'copy 'temp after .zf                                                     
      member_replaced = "yes"                                                   
      call delete_temp_file                                                     
   end /* if size(temp) > 0                                       */            
                                                                                
end /* if info = "no"      no word 'info' after u, default case   */            
else do /* info = "yes"    word 'info' after u                    */            
                                                                                
   /* Insert stdout. as infolines at top of edited member or      */            
   /* sequential file.                                            */            
   do i = stdout.0 to 1 by -1                                                   
      stdout = stdout.i                                                         
      'line_after 0 = infoline (stdout)'                                        
   end /* do i = stdout.0 to 1 by -1                              */            
   drop stdout.                                                                 
                                                                                
end     /* info = "yes"    word 'info' after u                    */            
                                                                                
'(member) = member'         /* Check if editing a library member. */            
if member <> '' &,          /* library member                     */            
   member_replaced = "yes" then do                                              
   zedsmsg = 'u u <- to restore'   /* top right corner            */            
   zedlmsg = 'You may issue Command ===> can or Command ===> save',             
             'or Command ===> u restore'                                        
end /* if member <> '' and replaced                               */            
else do /* not a library member                                   */            
   zedsmsg = ''                                                                 
   zedlmsg = ''                                                                 
end     /* not a library member                                   */            
address ispexec "setmsg msg(isrz000)"                                           
                                                                                
exit 0                                                                          
/*________________________________________________________________*/            
/*                                                                */            
check_parm:                                                                     
                                                                                
/* Check for special keywords: HELP, OEDIT, INFO                  */            
/* OEDIT: oedit the temporary file temp.                          */            
/*        if this file made empty, no change to edited member.    */            
/* INFO : Do not create a temporary file.                         */            
/*        stdout. written at top edited member as infolines.      */            
                                                                                
upper_parm = translate(parm) /* parm in uppercase                 */            
W1 = word(upper_parm,1)      /* first word of upper_parm          */            
if W1 = ''      !,     /* no parm or first word in list           */            
   wordpos(W1,'HELP -H --HELP ? /H') > 0 !, /* or 'HELP somewhere */            
   wordpos('HELP',upper_parm) > 0  then do                                      
     call show_help                                                             
     exit 0                                                                     
end /* if help needed                                             */            
                                                                                
/* The ISPF default command delimiter ZDEL is ';'                 */            
/* Cf Command ===> settings                                       */            
/* Replace '.,' or ',.' by ';'                                    */            
delim = '., ,.'                                                                 
do m = 1 to words(delim)                                                        
   posd = pos(word(delim,m),parm)                                               
   do while posd > 0               /* delimiter present           */            
      lend = length(word(delim,m)) /* length of string to replace */            
      /* substitute all '.,' by '; ' and ',.' by '; '             */            
      parm = substr(parm,1,posd-1)!!left(';',lend)!!substr(parm,posd+lend)      
      posd = wordpos(word(delim,m),parm)                                        
   end /* do while posd > 0           delimiter present           */            
end /* do m = 1 to words(delim)                                   */            
                                                                                
oedit = 'no' /* Shall we oedit the temporary file?                */            
             /* If empty, it will not replace the edited member.  */            
k = wordpos('OEDIT',upper_parm)                                                 
if k > 0 then do /* oedit present in parm                         */            
   oedit = "yes"                                                                
   parm = delword(parm,k,1)  /* remove oedit from parm            */            
end /* oedit present in parm                                      */            
                                                                                
info = 'no' /* Is string 'info' in mixed case, present in parm?   */            
            /* If yes, sandard output is placed at top of edited  */            
            /* member as infolines, and                           */            
            /* edited member is not saved and not changed.        */            
            /* If string 'info' in mixed case, is not present     */            
            /* in parm then edited member is saved and replaced.  */            
/* Default behavior is to save and replace.                       */            
/* We should add 'info' not to (save and replace).                */            
k = wordpos('INFO',upper_parm)                                                  
if k > 0 then do /* info present in parm                          */            
   info = "yes"                                                                 
   parm = delword(parm,k,1)  /* remove info from parm             */            
end /* info present in parm                                       */            
                                                                                
return                                                                          
/*________________________________________________________________*/            
/*                                                                */            
set_env:                                                                        
                                                                                
env.0 = 3                                                                       
env.1 = "PATH=.:/bin:usr/local/bin"                                             
env.2 = "LC_ALL="lc_all                                                         
env.3 = "_BPX_SHAREAS=MUST" /* ddname friendly, e.g. cat DD:DD01  */            
                            /* cat "dd:dd01(mbr)"                 */            
                                                                                
return                                                                          
/*________________________________________________________________*/            
/*                                                                */            
check_for_error: procedure expose rexxname bpxwunix_rc stderr. env. temp        
                                                                                
  if stderr.0 > 0 then do /* stderr.0 was expected                */            
     say rexxname": Execution of 'cmd' failed."                                 
     /* For debug:                                                              
     do i = 1 to stderr.0                                                       
        say 'stderr.'i' = 'stderr.i                                             
     end /* do i = 1 to stderr.0                                  */            
     */                                                                         
     /* Insert stderr. as infolines at top of edited member or    */            
     /* sequential file.                                          */            
     do i = stderr.0 to 1 by -1                                                 
        stderr = stderr.i                                                       
        'line_after 0 = infoline (stderr)'                                      
     end /* do i = stderr.0 to 1 by -1                            */            
                                                                                
     if info = "no" then call delete_temp_file                                  
                                                                                
     zispfrc = 16                                                               
     address ispexec 'vput zispfrc'                                             
     exit zispfrc                                                               
  end /* if stderr.0 > 0, stderr.0 was expected                   */            
                                                                                
return                                                                          
/*________________________________________________________________*/            
/*                                                                */            
delete_temp_file: procedure expose env. temp                                    
                                                                                
  drop stderr2.; stderr2.0 = 0                                                  
  cmd2 = 'rm 'temp /* remove temporary file                       */            
  call bpxwunix cmd2,,,stderr2.,env.                                            
     do i = 1 to stderr2.0 /* stderr2.0 is expected               */            
        say 'stderr2.'i' = 'stderr2.i                                           
     end /* do i = 1 to stderr2.0                                 */            
  drop env.                                                                     
                                                                                
return                                                                          
/*________________________________________________________________*/            
/*                                                                */            
save:                                                                           
                                                                                
  /* If a library member, save it in member 'SAVEU'               */            
  address isredit                                                               
    '(member) = member'                                                         
    'isredit (recs) = linenum .zl'   /* recs is total line number */            
    if member <> '' & recs <> 0 then do                                         
       save_member = 'SAVE'strip(left(rexxname,2))                              
       /* if rexxname = 'U' then save_member = 'SAVEU'            */            
       'repl ('save_member') .zf .zl' /* create if does not exist */            
       zedsmsg = member' saved in 'save_member                                  
       /*         ----+----1----+----2----   zedsmsg max 24 char  */            
       zedlmsg = 'Backup copy created in member 'save_member'.'                 
    end /* if member <> '' and is non empty                       */            
    else do /* file edited not a library member                   */            
       zedsmsg = 'Only for non empty mbr'                                       
       zedlmsg = 'Save command available only to save',                         
                 'a non empty library member.'                                  
    end /* file edited not a library member                       */            
  address /* from isredit                                         */            
                                                                                
  address ispexec "setmsg msg(isrz000)"                                         
                                                                                
return                                                                          
/*________________________________________________________________*/            
/*                                                                */            
restore:                                                                        
                                                                                
  /* If a library member, restore it from member 'SAVEU'.         */            
  address isredit                                                               
    '(member) = member'                                                         
    if member <> '' then do                                                     
       save_member = 'SAVE'strip(left(rexxname,2))                              
       /* if rexxname = 'U' then save_member = 'SAVEU'            */            
       'del all .zf .zl' /* delete all present content            */            
       'copy ('save_member') after .zf'  /* restore               */            
       zedsmsg = 'Member restored'                                              
       /*         ----+----1----+----2----   zedsmsg max 24 char  */            
       zedlmsg = 'Member restored from backup copy 'save_member                 
    end /* if member <> ''                                        */            
    else do /* file edited not a library member                   */            
       zedsmsg = 'Only for member'                                              
       zedlmsg = 'Restore command available only to restore',                   
                 'a library member.'                                            
    end /* file edited not a library member                       */            
  address /* from isredit                                         */            
                                                                                
  address ispexec "setmsg msg(isrz000)"                                         
                                                                                
return                                                                          
/*________________________________________________________________*/            
                                                                                
size:                                                                           
/* Size in bytes of a regular file.                    */                       
/* -1 if unknown, 0 if empty                           */                       
/* Example of call:                                    */                       
/*   temp = '/u/bozo/test01.txt'                       */                       
/*   size = size(temp)                                 */                       
parse arg path                                                                  
                                                                                
/* call syscalls 'ON' */                                                        
parse source . . . . . . envir .                                                
/* envir: host command environment                     */                       
if envir <> 'SH' then                                                           
   if syscalls('ON') > 3 then                                                   
      do                                                                        
      say 'Unable to establish the SYSCALL environment'                         
      say 'Return code : 'rc                                                    
      return -1      /* -1: cannot obtain size         */                       
      end                                                                       
                                                                                
address syscall                                                                 
  syscmd ='stat (path) st.'                                                     
  syscmd /* execute *                                  */                       
  syscmd_rc = rc                                                                
  call syscall_rc /* will return ok or nok             */                       
address /* from syscall                                */                       
                                                                                
if ok & st.0 <> 0 then ret = st.st_size                                         
                  else ret = -1                                                 
return ret                                                                      
                                                                                
/*_____________________________________________________*/                       
syscall_rc: procedure expose syscmd syscmd_rc retval errno errnojr,             
                             ok nok /* <- output       */                       
                                                                                
nok = syscmd_rc<>0 ! retval<0 ! retval=0 & (errno<>0 ! errnojr<>0)              
ok  = 1 - nok            /* ok  boolean, 1 if true     */                       
                                                                                
if nok then do                                                                  
   say 'syscall command = 'syscmd                                               
   say                                                                          
                                                                                
   /* not_OK information string                        */                       
   not_OK = '(rc<>0 ! retval<0 ! retval=0 & (errno<>0 ! errnojr<>0))'           
   say 'not_OK = 'not_OK                                                        
                                                                                
   say 'syscall rc                   =  'syscmd_rc                              
   say 'syscall return value retval  = 'retval                                  
   say 'syscall return code  errno   = 'errno                                   
   say 'syscall reason code  errnojr = 'errnojr                                 
                                                                                
   'strerror' errno errnojr 'err.' /* address syscall propagated */             
   /* if rc=0 & retval>=0 then do                      */                       
   if datatype(err.0) = 'NUM' then                                              
      if err.0 > 0 then do                                                      
         if err.se_errno  <> '' & err.se_errno  <> 'ERR.SE_ERRNO'  then         
            say '   errno   : 'err.se_errno                                     
         if err.se_reason <> '' & err.se_reason <> 'ERR.SE_REASON' then         
            say '   errnojr : 'err.se_reason                                    
         if err.se_action <> '' & err.se_action <> 'ERR.SE_ACTION' then         
            say '   action  : 'err.se_action                                    
      end /* if err.0 > 0                              */                       
   say                                                                          
end /* if nok                                          */                       
                                                                                
return                                                                          
/*___________________________________________________________________*/         
                                                                                
show_help:                                                                      
                                                                                
 say ' Help for 'rexxname':'                                                    
 /* Show help between 'Help starts' and 'Help ends'                  */         
 help = 'no'                                                                    
 line_counter = 0                                                               
 do i = 1 to sourceline()                                                       
    if pos('Help starts',sourceline(i)) > 0 then do                             
       help = "yes"                                                             
       iterate                                                                  
    end /* if pos('Help starts',sourceline(i)) > 0                   */         
    if pos('Help ends',sourceline(i)) > 0 then leave                            
    if help = 'yes' then do /* record sourceline(i)                  */         
       line_counter = line_counter + 1                                          
       line.line_counter = sourceline(i)                                        
    end /* if help = 'yes'                                           */         
 end /* do i = 1 to sourceline()                                     */         
 line.0 = line_counter                                                          
 call visualize                                                                 
return                                                                          
/*___________________________________________________________________*/         
                                                                                
 visualize: procedure expose line. rexxname                                     
 /* Visualize.                                                */                
 if line.0 > 0 then do                                                          
    if sysvar(sysispf) <> 'ACTIVE' then do                                      
       do i = 1 to line.0                                                       
          say line.i                                                            
       end /* do i = 1 to line.0                              */                
       zispfrc = 0                                                              
       exit zispfrc                                                             
    end /* if sysvar(sysispf) <> 'ACTIVE'                     */                
    else do /*       ispf ACTIVE                              */                
                                                                                
       /* Allocate visualization file.                        */                
       address tso                                                              
       ran  = right(random(1,99999),5,'0')                                      
       ddnm = 'dd'ran                          /* choose random ddname */       
       call set_up_prefix /* create prefix for new file                */       
       dsnprint = prefix"."rexxname".R"ran                                      
       msg_prev = msg('off')                                                    
       "alloc file("ddnm") da('"dsnprint"') new catalog",                       
       "tracks space(5,5) reuse lrecl(132) recfm(f b) blksize(0)"               
       alloc_rc = rc                                                            
       if alloc_rc <> 0 then do                                                 
          say rexxname "could not allocate the visualization file."             
          say "We exit with code 16."                                           
          say "alloc rc = "alloc_rc                                             
          zispfrc = 16                                                          
          address ispexec 'vput zispfrc'                                        
          exit zispfrc                                                          
       end /* if alloc_rc <> 0                                */                
       msg_off  = msg(msg_prev)                                                 
       /* End of allocate visualization file.                 */                
                                                                                
       /* Write on visualization file.                        */                
       "execio" line.0  "diskw" ddnm "(stem line. finis"                        
       execio_rc = rc                                                           
       if execio_rc <> 0 then do                                                
          say rexxname "could not write on visualization file."                 
          say "We exit with code 16."                                           
          say "execio rc = "execio_rc                                           
          zispfrc = 16                                                          
          address ispexec 'vput zispfrc'                                        
          exit zispfrc                                                          
       end /* if execio_rc <> 0                               */                
       /* End of write on visualization file.                 */                
                                                                                
       /* Visualize.                                          */                
       zedsmsg = 'F3 to exit'  /* top right corner            */                
       zedlmsg = 'To exit, press F3.',                                          
                 'Temporary help file will be deleted.'                         
       ispexec "setmsg msg(isrz000)"                                            
       ispexec "view dataset('"dsnprint"')"                                     
       /* End of visualize.                                   */                
                                                                                
       /* Clean up.                                           */                
       msg_prev = msg('off')                                                    
          "free fi("ddnm")"                                                     
          "del  '"dsnprint"'"                                                   
       msg_off  = msg(msg_prev)     /* reset                  */                
       /* End of clean up.                                    */                
                                                                                
    end /* ispf ACTIVE                                        */                
 end /* if line.0 > 0                                         */                
                                                                                
 return                                                                         
 /*___________________________________________________________________*/        
                                                                                
 set_up_prefix:                                                                 
                                                                                
 /* Set up new output file prefix.                                    */        
 prefix = sysvar('syspref')              /* tso profile prefix        */        
 uid    = sysvar('sysuid')               /* tso userid                */        
 if prefix = '' then prefix = uid        /* use uid if null prefix    */        
 if prefix <> '' & prefix <> uid then    /* different prefix than uid */        
    prefix = prefix'.'uid                /* use prefix.uid            */        
                                                                                
 return                                                                         
 /*___________________________________________________________________*/        
