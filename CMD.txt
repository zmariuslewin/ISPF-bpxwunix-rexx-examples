/* rexx */                                                                      
 trace o                                                                        
 parse arg cmd                                                                  
 /* _______________________________________________________________ */          
 /*                                                                 */          
 /* Called module.                                                  */          
 /* May be used to edit macroless.                                  */          
 /* Maximum length of only parameter is 230 with case preserved.    */          
 /* Execute the parameter content.                                  */          
 /* Example 1: (Edition of a MVS sequential file or z/OS Unix file) */          
 /*   cmd = "epdf 'BOZO.SEQ'; c 'abc' 'DEF' all; save; end"         */          
 /*   call cmd(cmd)                                                 */          
 /* Example 2: (Edition of a z/OS Unix file)                        */          
 /*   cmd = 'tso oedit test.txt; c mon my all; save; end'           */          
 /*   call cmd(cmd)                                                 */          
 /* Example 3: (Calling a rexx)                                     */          
 /*   call cmd("tso time; tso rexx01 parm1 parm2")                  */          
 /*                                                                 */          
 /* The rexx is appending ";end' to cmd with the intent             */          
 /* to leave the auxiliary panel used to issue commands.            */          
 /* There are several ways to remove the last 'end', to stay        */          
 /* for instance in edit on a file:                                 */          
 /* 1) Add to cmd a large enough number of spaces which will        */          
 /*    shift out the string ';end' added by default at the right    */          
 /*    of cmd.                                                      */          
 /*    E.g. cmd = cmd!!copies(' ',400)                              */          
 /* 2) Insert 'no end' or 'NO END' or 'noend' or 'NOEND'            */          
 /*    anywhere in cmd. The added string 'no end' or                */          
 /*    'NO END' or 'noend' or 'NOEND' will be removed               */          
 /*    and no string ';end' will be appended to cmd.                */          
 /* 3) If the maximum number of screens (8 to 32) is not yet        */          
 /*    reached, append ';start' at the end of cmd. A new            */          
 /*    screen will be created and the ';end' string automatically   */          
 /*    added, will remove it. If the maximum number of screens      */          
 /*    is already attained, the appended ';end' will operate        */          
 /*    on the present screen.                                       */          
 /*                                                                 */          
 /* Example 4: (Stay in edit)                                       */          
 /*   cmd = 'tso oedit test.txt; c abc def all    no end'           */          
 /*   call cmd(cmd)                                                 */          
 /* Example 5: (View output file generated by c rexx,               */          
 /*             c d a issue the 'd a' MVS command)                  */          
 /*   cmd = "tso time; tso c d a;"copies(' ',400)                   */          
 /*   call cmd(cmd)                                                 */          
 /* Example 6: (Access customized panel to issue commands)          */          
 /*   cmd = 'tso noend'                                             */          
 /*   call cmd(cmd)                                                 */          
 /* _______________________________________________________________ */          
                                                                                
 address ispexec; 'control errors return'; zerrmsg=''                           
                                                                                
 mypanel = 'xispcmde' /* panel between *PANEL and *ENDPANEL        */           
 call panel mypanel /* copy imbedded panel to temp lib, libdef     */           
 "control nondispl enter"                                                       
                                                                                
/* By default, we append ";end" to cmd to leave panel.             */           
/* If string 'no end' or 'noend' or regular expression             */           
/* ¬nN|¬oO| *¬eE|¬nN|¬dD| present in cmd, remove it,               */           
/* else append ";end" to cmd (default)                             */           
/*      (intent: to leave auxiliary panel used to issue commands). */           
/* say "cmd = "cmd                                                 */           
zcmd = is_no_end_present_in_command(cmd)                                        
/* say "zcmd = "zcmd                                               */           
                                                                                
 "display panel("mypanel")" /* execute zcmd                        */           
 call panel         /* libdef, free                                */           
 exit                                                                           
                                                                                
/* __ Modified ISPCMDE panel ______________________________________*/           
/* delimited by *panel and *endpanel                               */           
/*                                                                 */           
/* It is placed in an unexecuted part of the rexx.                 */           
/*                                                                 */           
/* call panel 'xispcmde'                                           */           
/* will extract what is between *panel and *endpanel               */           
/* place it as a member named 'xispcmde' of a temporary library    */           
/* and libdef this library.                                        */           
                                                                                
*panel                                                                          
)attr format(mix)                                                               
     _ type(input) caps(off) just(left)                                         
)body cmd(zcmd) asis                                                            
     _zcmd                                                                      
                                                                                
                                                                                
+ F3 to exit or issue case sensitive command as in Command ===>                 
+                                                                               
+ E.g. to edit a copy of a library member to my home directory:                 
+ epdf 'bozo.pdse(mbr1)' v; rep ./mbr1 .zf .zl; end; tso oedit ./mbr1           
+ (v view, rep replace, ./mbr1 created or replaced file, .zf first line,        
+ .zl last line)                                                                
)init                                                                           
)proc                                                                           
)end                                                                            
*endpanel                                                                       
                                                                                
/*_________________________________________________________________*/           
panel: procedure expose set_panel paneldd paneldd2 panelds                      
parse arg panel                                                                 
                                                                                
 if set_panel = 1 then signal unset_panel                                       
 set_panel = 1    /* switch                                        */           
                                                                                
 set_panel:                                                                     
 address tso                                                                    
                                                                                
/* Extract imbedded panel into panel. stem _______________________ */           
 panel.  = ''        /* initialize                                 */           
 panel.0 = 0                                                                    
 count= 0 /* panel stem index                                      */           
 skip = 'yes'                                                                   
 do i = 1 to sourceline()                                                       
    line = sourceline(i)                                                        
    select                                                                      
      when translate(left(line,6)) = '*PANEL'     then skip = 'no'              
      when translate(left(line,9)) = '*ENDPANEL'  then leave                    
      when skip = 'no' then do                                                  
        count = count + 1                                                       
        panel.count = line                                                      
        iterate                                                                 
      end /* when skip = 'no'                                      */           
      otherwise nop                                                             
    end /* select                                                  */           
 end /* do i = 1 to sourceline()                                   */           
 panel.0 = count                                                                
/* End of extract imbedded panel into panel. stem ________________ */           
                                                                                
/*________  Allocate temporary panel library ______________________*/           
 address tso                                                                    
 ran  = right(random(1,99999),5,'0')                                            
 paneldd = 'dd'ran                         /* choose random ddname */           
 call set_up_prefix /* create prefix for new file                  */           
 parse source . . rexxname .    /* rexxname in upper case          */           
 panelds = prefix"."rexxname".PANEL.R"ran                                       
 msg_prev = msg('off')                                                          
 "alloc file("paneldd") da('"panelds"') new catalog",                           
 "dsntype(library,2) space(1,1) dir(1) tracks",                                 
 "recfm(f b) lrecl(80) reuse"                                                   
 alloc_rc = rc                                                                  
 if alloc_rc <> 0 then do                                                       
    say rexxname "could not allocate panel library "panelds"."                  
    say "We exit with code 16."                                                 
    say "alloc rc = "alloc_rc                                                   
    zispfrc = 16                                                                
    if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'           
    exit zispfrc                                                                
 end /* if alloc_rc <> 0                                   */                   
 msg_off  = msg(msg_prev)                                                       
/*________  End of allocate temporary panel library _______________*/           
                                                                                
/* Copy stem into panel.                                           */           
 ran  = right(random(1,99999),5,'0')                                            
 paneldd2 = 'dd2'ran                       /* choose random ddname */           
   "alloc fi("paneldd2") da('"panelds"("panel")') shr reuse "                   
         alloc_paneldd2_rc = rc                                                 
         call check_rc alloc_paneldd2_rc,0,'alloc paneldd2'                     
                                                                                
/* Copy panel into temporary library member                        */           
   address mvs "execio * diskw "paneldd2" (stem panel. fini"                    
         execio_rc = rc                                                         
         msg_prev = msg('off')                                                  
           address tso   "free f("paneldd2")"                                   
         msg_off  = msg(msg_prev)                                               
         call check_rc execio_rc,0,'execio'                                     
   address /* from tso                                             */           
                                                                                
/* Libdef temporary library                                        */           
   address ispexec; 'control errors return';zerrmsg=''                          
     "libdef ispplib library id("paneldd") stack"                               
         libdef_paneldd_rc = rc                                                 
         call check_rc libdef_paneldd_rc,0,'libdef paneldd'                     
   address /* from ispexec                                         */           
                                                                                
   return                                                                       
                                                                                
 unset_panel:                                                                   
     set_panel = 0    /* switch                                    */           
     address ispexec "libdef ispplib  "                                         
         libdef_rc = rc                                                         
         call check_rc libdef_rc,0,'libdef'                                     
     msg_prev = msg('off')                                                      
       address tso   "free f("paneldd") del"                                    
     msg_off  = msg(msg_prev)                                                   
   return                                                                       
                                                                                
/*_ End of panel procedure ________________________________________*/           
 check_rc:                                                                      
                                                                                
  /* call example:    call check_rc rc,0,'libdef isptlib'          */           
  /* In case of error:                                                          
  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG     
  */                                                                            
  if arg(1)<=arg(2) then return                                                 
  if zerrmsg <> '' & zerrmsg <> 'ZERRMSG'                                       
     then say 'ZERRMSG  = 'ZERRMSG                                              
  /* ISPEXEC or ISREDIT error:                                     */           
  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM                        
  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM                        
  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO                      
  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG                      
  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG                      
  say 'rc = 'arg(1)                                                             
  if debug='DEBUG' then                                                         
    say 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg                             
  zispfrc = 16                                                                  
  if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'             
  exit zispfrc                                                                  
 /*___________________________________________________________________*/        
                                                                                
 set_up_prefix:                                                                 
                                                                                
 /* Set up new output file prefix.                                    */        
 prefix = sysvar('syspref')              /* tso profile prefix        */        
 uid    = sysvar('sysuid')               /* tso userid                */        
 if prefix = '' then prefix = uid        /* use uid if null prefix    */        
 if prefix <> '' & prefix <> uid then    /* different prefix than uid */        
    prefix = prefix'.'uid                /* use prefix.uid            */        
                                                                                
 return                                                                         
 /*___________________________________________________________________*/        
                                                                                
is_no_end_present_in_command: procedure                                         
 /* Otherwise, we append ";end" to command                         */           
 parse arg command                                                              
 command = strip(command)                                                       
                                                                                
 /* For bpxwunix command codepage:                                 */           
 lc_all = "Fr_FR.IBM-1147"        /* lc_all = "En_US.IBM-1140"     */           
 /* We use French square brackets in first parameter to bpxwunix.  */           
                                                                                
 /*________________________________________________________________*/           
 /*                                                                */           
 /* Execute bpxwunix.                                              */           
 /*________________________________________________________________*/           
                                                                                
 call set_env /* z/OS Unix environment variables                   */           
 drop stderr.; stderr.0 = 0    /* initialize standard error stem   */           
                                                                                
 /* We use a new stack as standard input to bpxwunix and           */           
 /* the same stack as standard output from bpxwunix.               */           
 old_command = command                                                          
 address tso                                                                    
 "newstack"                                                                     
 queue old_command /* result obtained with parse pull new_command  */           
 cmd = "sed 's/[nN][oO] *[eE][nN][dD]//' "     /* remove first     */           
 call bpxwunix cmd,"stack","stack",stderr.,env.                                 
 bpxwunix_rc = rc                                                               
                                                                                
 if stderr.0 > 0 then do                                                        
    parse source . . rexxname .    /* rexxname in upper case       */           
    say rexxname': Bpxwunix standard error:'                                    
    do i = 1 to stderr.0                                                        
       say right(i,6) stderr.i                                                  
    end /* do i = 1 to stderr.0                                    */           
                                                                                
    zispfrc = 16                                                                
    say rexxname": Command >"command"<"                                         
    say rexxname": Error when checking for 'no end' in command."                
    say rexxname": We exit with code "zispfrc"."                                
    if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'           
    "delstack"                                                                  
    drop stderr. env.                                                           
    exit zispfrc                                                                
 end /* if stderr.0 > 0                                            */           
                                                                                
 parse pull new_command /* preserve case                           */           
 "delstack"                                                                     
                                                                                
 /* new_command = old_command if string 'no end' not found         */           
 if new_command = old_command then command = command";end"                      
 else command = new_command /* string 'no end' removed             */           
                                                                                
 drop stderr. env.                                                              
 address /* from tso                                               */           
 return command                                                                 
                                                                                
 /*________________________________________________________________*/           
 /*                                                                */           
 set_env:                                                                       
                                                                                
 env.0 = 3                                                                      
 env.1 = "PATH=.:/bin:usr/local/bin"                                            
 env.2 = "LC_ALL="lc_all                                                        
 env.3 = "_BPX_SHAREAS=MUST" /* ddname friendly, e.g. cat DD:DD01  */           
                             /* cat "dd:dd01(mbr)"                 */           
                                                                                
 return                                                                         
 /*________________________________________________________________*/           
